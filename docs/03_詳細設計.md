# 詳細設計書 - リアルタイムチャットアプリケーション

## クラス・モジュール単位の責務

### サーバーサイド

#### 1. SocketManager クラス
```typescript
/**
 * WebSocket接続の管理とイベントディスパッチを担当
 */
class SocketManager {
  private io: Server;
  private userManager: UserManager;
  private messageStore: MessageStore;

  /**
   * Socket.IOサーバーを初期化
   * @param server HTTP Server instance
   */
  constructor(server: any);
  
  /**
   * クライアント接続時の処理
   * @param socket Socket.IO接続インスタンス
   */
  handleConnection(socket: Socket): void;
  
  /**
   * ユーザー参加処理
   * @param socket 接続中のソケット
   * @param data 参加データ（ニックネーム）
   */
  handleJoinRoom(socket: Socket, data: JoinRoomData): void;
  
  /**
   * メッセージ送信処理
   * @param socket 送信者ソケット
   * @param data メッセージデータ
   */
  handleSendMessage(socket: Socket, data: SendMessageData): void;
  
  /**
   * 切断処理
   * @param socket 切断されるソケット
   */
  handleDisconnect(socket: Socket): void;
}
```

#### 2. UserManager クラス
```typescript
/**
 * ユーザー情報の管理と操作を担当
 */
class UserManager {
  private users: Map<string, User> = new Map();
  
  /**
   * ユーザーを追加
   * @param socketId ソケットID
   * @param nickname ニックネーム
   * @returns User ユーザーオブジェクト
   * @throws Error ニックネーム重複時
   */
  addUser(socketId: string, nickname: string): User;
  
  /**
   * ユーザーを削除
   * @param socketId ソケットID
   * @returns User | null 削除されたユーザー
   */
  removeUser(socketId: string): User | null;
  
  /**
   * ユーザー取得
   * @param socketId ソケットID
   * @returns User | null ユーザー情報
   */
  getUser(socketId: string): User | null;
  
  /**
   * 全ユーザーのニックネーム一覧取得
   * @returns string[] ニックネーム配列
   */
  getAllNicknames(): string[];
  
  /**
   * ニックネーム重複チェック
   * @param nickname チェック対象ニックネーム
   * @returns boolean 重複している場合true
   */
  isNicknameExists(nickname: string): boolean;
}
```

#### 3. MessageStore クラス
```typescript
/**
 * メッセージの保存と取得を担当
 */
class MessageStore {
  private messages: Message[] = [];
  private readonly MAX_MESSAGES = 100;
  
  /**
   * メッセージを保存
   * @param message Messageオブジェクト
   */
  addMessage(message: Message): void;
  
  /**
   * 最新メッセージ一覧取得
   * @param limit 取得件数（デフォルト: 50）
   * @returns Message[] メッセージ配列
   */
  getRecentMessages(limit: number = 50): Message[];
  
  /**
   * 全メッセージ削除（管理機能）
   */
  clearMessages(): void;
  
  /**
   * メッセージ総数取得
   * @returns number メッセージ数
   */
  getMessageCount(): number;
}
```

### クライアントサイド

#### 1. ChatClient クラス
```typescript
/**
 * チャット機能のメインコントローラー
 */
class ChatClient {
  private socket: SocketClient;
  private ui: UIManager;
  private isConnected: boolean = false;
  private currentUser: string | null = null;
  
  /**
   * チャットクライアントを初期化
   */
  constructor();
  
  /**
   * サーバーに接続
   * @param nickname ユーザーのニックネーム
   * @throws Error 接続失敗時
   */
  async connect(nickname: string): Promise<void>;
  
  /**
   * メッセージを送信
   * @param message 送信するメッセージ
   */
  sendMessage(message: string): void;
  
  /**
   * 接続を切断
   */
  disconnect(): void;
  
  /**
   * 接続状態を取得
   * @returns boolean 接続中の場合true
   */
  isConnectedToServer(): boolean;
}
```

#### 2. SocketClient クラス
```typescript
/**
 * Socket.IOクライアントの管理
 */
class SocketClient {
  private socket: Socket;
  private eventHandlers: Map<string, Function[]> = new Map();
  
  /**
   * Socket.IOクライアントを初期化
   * @param serverUrl サーバーURL
   */
  constructor(serverUrl: string);
  
  /**
   * イベントリスナーを登録
   * @param event イベント名
   * @param handler ハンドラー関数
   */
  on(event: string, handler: Function): void;
  
  /**
   * イベントを発行
   * @param event イベント名
   * @param data 送信データ
   */
  emit(event: string, data: any): void;
  
  /**
   * 接続を開始
   */
  connect(): void;
  
  /**
   * 接続を切断
   */
  disconnect(): void;
}
```

#### 3. UIManager クラス
```typescript
/**
 * ユーザーインターフェースの管理
 */
class UIManager {
  private elements: {
    nicknameForm: HTMLFormElement;
    chatContainer: HTMLElement;
    messagesList: HTMLElement;
    messageInput: HTMLInputElement;
    sendButton: HTMLButtonElement;
    usersList: HTMLElement;
  };
  
  /**
   * UI要素を初期化
   */
  constructor();
  
  /**
   * ログイン画面を表示
   */
  showLoginScreen(): void;
  
  /**
   * チャット画面を表示
   * @param nickname 現在のユーザー名
   */
  showChatScreen(nickname: string): void;
  
  /**
   * メッセージを画面に追加
   * @param message メッセージオブジェクト
   */
  addMessage(message: MessageData): void;
  
  /**
   * システムメッセージを表示
   * @param text システムメッセージ
   */
  addSystemMessage(text: string): void;
  
  /**
   * 参加者リストを更新
   * @param users ユーザー名配列
   */
  updateUsersList(users: string[]): void;
  
  /**
   * 入力フィールドをクリア
   */
  clearMessageInput(): void;
  
  /**
   * エラーメッセージを表示
   * @param error エラーメッセージ
   */
  showError(error: string): void;
}
```

## 入出力・例外・前後条件

### SocketManager.handleJoinRoom

#### 入力
```typescript
interface JoinRoomData {
  nickname: string; // 1-20文字、英数字・日本語
}
```

#### 前提条件
- Socket接続が確立されている
- ニックネームが未設定状態

#### 処理フロー
1. ニックネームバリデーション実行
2. 重複チェック実行
3. ユーザー情報を登録
4. 参加通知を全員に送信
5. 既存メッセージ履歴を送信

#### 出力（正常）
```typescript
// 新規参加者に送信
{
  event: 'join-success',
  data: { nickname: string, users: string[], messages: Message[] }
}

// 既存参加者に送信
{
  event: 'user-joined',
  data: { nickname: string, timestamp: string }
}
```

#### 例外処理
- **ニックネーム重複**: `nickname-taken` エラー送信
- **不正な文字**: `invalid-nickname` エラー送信
- **接続数上限**: `room-full` エラー送信

#### 事後条件
- ユーザーがアクティブユーザー一覧に追加される
- 他の参加者に新規参加が通知される

### MessageStore.addMessage

#### 入力
```typescript
interface Message {
  id: string;      // UUID v4
  userId: string;  // Socket ID
  nickname: string; // 1-20文字
  message: string;  // 1-500文字
  timestamp: Date;  // 送信日時
}
```

#### 前提条件
- メッセージオブジェクトが適切に構築されている
- 送信者が認証済み

#### 処理フロー
1. メッセージ配列に追加
2. 上限チェック（100件）
3. 上限超過時は古いメッセージを削除
4. インデックス更新

#### 出力
- 戻り値なし（void）
- メッセージが内部配列に保存される

#### 例外処理
- **メモリ不足**: エラーログ記録、処理継続
- **不正データ**: バリデーションエラーログ

#### 事後条件
- メッセージが永続化される（メモリ内）
- メッセージ総数が上限内で維持される

## データ構造とアルゴリズム

### メッセージ配信アルゴリズム

#### 概要
新しいメッセージを全接続クライアントにリアルタイム配信

#### 擬似コード
```typescript
function broadcastMessage(senderId: string, message: string): void {
  // 1. 送信者情報取得
  const sender = userManager.getUser(senderId);
  if (!sender) throw new Error('Sender not found');
  
  // 2. メッセージオブジェクト構築
  const messageObj: Message = {
    id: generateUUID(),
    userId: senderId,
    nickname: sender.nickname,
    message: sanitizeInput(message),
    timestamp: new Date()
  };
  
  // 3. メッセージ保存
  messageStore.addMessage(messageObj);
  
  // 4. 全クライアントに配信
  io.emit('receive-message', {
    event: 'receive-message',
    data: messageObj
  });
  
  // 5. ログ記録
  logger.info('Message sent', { 
    userId: senderId, 
    messageId: messageObj.id 
  });
}
```

#### 計算量
- 時間計算量: O(n) - nは接続クライアント数
- 空間計算量: O(1) - メッセージ1件分のメモリ

### 接続管理アルゴリズム

#### データ構造
```typescript
// アクティブユーザー管理: ハッシュマップ使用
Map<string, User> // Key: Socket ID, Value: User info

// メッセージ履歴: 配列使用（FIFO）
Message[] // 最新100件を保持
```

#### 接続数制限チェック
```typescript
function checkConnectionLimit(): boolean {
  const currentConnections = userManager.getUserCount();
  const maxConnections = 50;
  return currentConnections < maxConnections;
}
```

## 設定値・環境依存の扱い

### 環境変数
```typescript
// vercel.json または環境設定
interface Config {
  // サーバー設定
  PORT: number;                    // デフォルト: 3000
  NODE_ENV: 'development' | 'production';
  
  // チャット設定
  MAX_USERS: number;              // デフォルト: 50
  MAX_MESSAGES: number;           // デフォルト: 100
  MAX_MESSAGE_LENGTH: number;     // デフォルト: 500
  RATE_LIMIT_PER_SECOND: number;  // デフォルト: 3
  
  // セキュリティ設定
  CORS_ORIGIN: string;            // デフォルト: '*'
  ENABLE_RATE_LIMIT: boolean;     // デフォルト: true
}
```

### 設定ファイル構造
```typescript
// config/default.ts
export const defaultConfig: Config = {
  PORT: 3000,
  NODE_ENV: 'development',
  MAX_USERS: 50,
  MAX_MESSAGES: 100,
  MAX_MESSAGE_LENGTH: 500,
  RATE_LIMIT_PER_SECOND: 3,
  CORS_ORIGIN: process.env.CORS_ORIGIN || '*',
  ENABLE_RATE_LIMIT: true
};

// config/production.ts
export const productionConfig: Partial<Config> = {
  NODE_ENV: 'production',
  CORS_ORIGIN: 'https://your-domain.vercel.app'
};
```

## テスト観点

### ユニットテスト

#### UserManager クラス
```typescript
describe('UserManager', () => {
  test('ユーザー追加が正常に動作する', () => {
    const manager = new UserManager();
    const user = manager.addUser('socket1', 'testuser');
    
    expect(user.nickname).toBe('testuser');
    expect(manager.getUser('socket1')).toBe(user);
  });
  
  test('重複ニックネームでエラーが発生する', () => {
    const manager = new UserManager();
    manager.addUser('socket1', 'testuser');
    
    expect(() => {
      manager.addUser('socket2', 'testuser');
    }).toThrow('Nickname already exists');
  });
  
  test('ユーザー削除が正常に動作する', () => {
    const manager = new UserManager();
    manager.addUser('socket1', 'testuser');
    const removed = manager.removeUser('socket1');
    
    expect(removed?.nickname).toBe('testuser');
    expect(manager.getUser('socket1')).toBeNull();
  });
});
```

#### MessageStore クラス
```typescript
describe('MessageStore', () => {
  test('メッセージ追加と取得が正常に動作する', () => {
    const store = new MessageStore();
    const message: Message = {
      id: 'test-id',
      userId: 'socket1',
      nickname: 'testuser',
      message: 'Hello World',
      timestamp: new Date()
    };
    
    store.addMessage(message);
    const messages = store.getRecentMessages();
    
    expect(messages).toContain(message);
    expect(store.getMessageCount()).toBe(1);
  });
  
  test('メッセージ上限で古いメッセージが削除される', () => {
    const store = new MessageStore();
    // MAX_MESSAGES + 1 件のメッセージを追加
    for (let i = 0; i <= 100; i++) {
      store.addMessage(createTestMessage(`msg${i}`));
    }
    
    expect(store.getMessageCount()).toBe(100);
    const messages = store.getRecentMessages();
    expect(messages[0].message).toBe('msg1'); // msg0が削除されている
  });
});
```

### 結合テスト

#### Socket通信テスト
```typescript
describe('Socket Integration', () => {
  let server: Server;
  let clientSocket: Socket;
  
  beforeAll(() => {
    server = createTestServer();
  });
  
  test('ユーザー参加フローが正常に動作する', (done) => {
    clientSocket = createTestClient();
    
    clientSocket.on('join-success', (data) => {
      expect(data.nickname).toBe('testuser');
      expect(Array.isArray(data.users)).toBe(true);
      done();
    });
    
    clientSocket.emit('join-room', { nickname: 'testuser' });
  });
  
  test('メッセージ送受信が正常に動作する', (done) => {
    const testMessage = 'Hello World';
    
    clientSocket.on('receive-message', (data) => {
      expect(data.message).toBe(testMessage);
      expect(data.nickname).toBe('testuser');
      done();
    });
    
    clientSocket.emit('send-message', { message: testMessage });
  });
});
```

### E2Eテスト

#### ブラウザテスト（Playwright使用想定）
```typescript
describe('Chat E2E Tests', () => {
  test('複数ユーザーでのチャット動作', async () => {
    // ユーザー1がチャットに参加
    const page1 = await browser.newPage();
    await page1.goto('http://localhost:3000');
    await page1.fill('#nickname', 'User1');
    await page1.click('#join-btn');
    
    // ユーザー2がチャットに参加
    const page2 = await browser.newPage();
    await page2.goto('http://localhost:3000');
    await page2.fill('#nickname', 'User2');
    await page2.click('#join-btn');
    
    // ユーザー1がメッセージ送信
    await page1.fill('#message-input', 'Hello from User1');
    await page1.click('#send-btn');
    
    // ユーザー2でメッセージ受信確認
    await page2.waitForSelector('[data-testid="message"]:has-text("Hello from User1")');
    
    // 参加者リスト確認
    await expect(page1.locator('#users-list')).toContainText('User1');
    await expect(page1.locator('#users-list')).toContainText('User2');
  });
  
  test('ニックネーム重複エラーハンドリング', async () => {
    const page = await browser.newPage();
    await page.goto('http://localhost:3000');
    await page.fill('#nickname', 'ExistingUser');
    await page.click('#join-btn');
    
    await expect(page.locator('.error-message'))
      .toContainText('このニックネームは既に使用されています');
  });
});
```

### パフォーマンステスト

#### 負荷テスト観点
- 同時接続50ユーザーでの安定性確認
- メッセージ送信レート上限での動作確認
- メモリ使用量の監視（メッセージ蓄積）
- レスポンス時間の測定（接続〜メッセージ表示まで）